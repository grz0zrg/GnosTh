;     ___                     _   _     
;    / _ \  ____   ___   ___ | |_| |__  
;   / /_\/ |  _ \ / _ \ / __│| __| '_ \ 
;  / ╱ ╲ \ | | | | (_) |\__ \| |_| | | |
;  \ ╲_/ / |_| |_|\___/ |___/ \__|_| |_|
;   \___/ Gnos Forth testing code by grz
; ------------------------------------->
; this program use all lang. features as
; a raw way to check compiler behavior,a
; memory write is used after each result
; to ensure instru. output for LLVM LLC.
; ------------------------------------->

: write_addr 8000

: str write_addr ! 

; 0
: zeq2 1 0= str

; -1
: zeq1 0 0= str

; -1
: zne2 1 0<> str

; 0
: zne1 0 0<> str

; 0
: eq2 7 8 = str

; -1
: eq1 8 8 = str

; -1
: ne2 7 8 <> str

; 0
: ne1 8 8 <> str

; -1
: lt3 8 9 < str

; 0
: lt2 9 8 < str

; 0
: lt1 8 8 < str

; 0
: gt3 8 9 > str

; -1
: gt2 9 8 > str

; 0
: gt1 8 8 > str

; 0
: le2 8 4 <= str

; -1
: le1 4 8 <= str

; -1
: ge2 8 4 >= str

; 0
: ge1 4 8 >= str

; -10
: not 9 ~ str

; 1
: and 9 5 & str

; 13
: or 9 5 | str

; 12
: xor 9 5 ^ str

; 128
: shl 10 3 << str

; 2
: ashr 10 3 >> str

; 2147483640
: lshr 10 negate 1 >>> str

; 6
: rgA 6 A! A@ str

; 7
: rgB 7 B! B@ str

; 8
: rgC 8 C! C@ str

; 9
: rgD 9 D! D@ str

; -8
: neg 8 negate str

; 64
: mul 8 8 * str

; 4
: div 8 2 / str

; 2
: mod 8 6 % str

; 16
: fpm 8 4 2 */ str

; 6
: shm 8 8 2 >>- str

; 10
: shp 8 8 2 >>+ str

; 40
: sub 32 a - str

; 60
: add 32 a + str

; stack result: 1 3 1 2
: stack 1 2 3 rot swap over dup 1 + drop str str str str

; output result: baaaaaad
: m32 baaaaaad write_addr ! write_addr @ drop

; output result: ad
: m8 baaaaaad write_addr db! write_addr db@ drop

; output result: 8
: arr [ c a f e d 0 0 d ] dlen str drop

; computed output address: 164352
: plot 66 80 80 100 write_addr pix

; output result: 144
: alot #10 align #90 allot dlen str drop

; output result: 42
: var 2a >hitchhiker hitchhiker str

; output result: 11
: string "hello world" dlen str str

; output result: 99
: char 'c' str

: words entrypoint
    ; regular
    add sub shp shm fpm mod div mul neg
    rgA rgB rgC rgD
    lshr ashr shl xor or and not
    ge1 ge2 le1 le2 gt1 gt2 gt3 lt1 lt2 lt3 ne1 ne2 eq1 eq2 zne1 zne2 zeq1 zeq2
    stack
    m32 m8 arr plot alot var

    ; string / char
    string char

    ; flow
    loop
        1 0<> if
            8 str
        then

        0 0<> if
            ; path not taken
            (8 4 +) str ; 12

            8 for >i
                0 4 1 do >j
                next
            next
            i str ; shall be 0
            j str ; shall be 4
        else
            (6 4 +) str ; 10

            0 8 1 do >i
            next
            i str ; shall be 8

            8 0 3 do >i
            next
            i str ; shall be 2

            2 >i
            loop
                i 1 - dup >i 0 <> until
            i str ; shall be 0
        then
    again

    ; specials / syntactic sugar
    #deadc0de #!
    $deadc0de

    ; quotation / case (unsupported in transpile mode)
    {
        1 1 + str
    } call

    'a' {
        60 {
            "0 case" str
        } case
        61 {
            "1 case" str
        } case
        62 {
            "2 case" str
        } case
        "unknown case" str drop
    } 'c' over call call

    ; API (some may be unsupported in transpile mode)
    tstc getc gett dev_enum dev_open dev_close dev_write
    reset udelay envget envset putc puts cache_care